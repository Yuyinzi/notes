## 运行时数据区域
`Java`虚拟机所管理的内存包括五个运行时数据区域:
![运行时数据区](https://upload-images.jianshu.io/upload_images/12157360-7fec7341093cecc4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
### 程序计数器
 为了线程切换后能恢复到正确的执行位置， 每条线程都需要有一个独立的程序计数器,因而程序计数器是线程私有的内存.**此内存区域是唯一一个在《Java虚拟机规范》 中没有规定任何`OutOfMemoryError`情况的区域**。
如果线程正在执行的是`Java`方法,计数器记录的正在执行的虚拟机字节码指令的地址;如果执行的是`native`方法(本地方法,原生函数),计数器的值为空.
### 虚拟机栈
与程序计数器一样,它也是线程私有的,生命周期与线程相同.每个方法被执行时,都会创建一个**栈帧**,用于存储方法的相关信息(局部变量表等),进行入栈,当方法执行完毕后,执行出栈的操作.
如果线程请求的栈深度大于虚拟机所允许的深度，将抛出`StackOverflowError`异常； 如果`Java`虚拟机栈容量可以动态扩展，当栈扩展时无法申请到足够的内存会抛出`OutOfMemoryError`异常。
### 本地方法栈
本地方法栈与虚拟机栈所发挥的作用是非常相似的，其区别只是虚拟机栈为虚拟机执行`Java`方法（也就是字节码） 服务，而本地方法栈则是为虚拟机使用到的本地（`Native`）方法服务。
与虚拟机栈一样， 本地方法栈也会在线程请求的栈深度大于虚拟机所允许的最大深度或者允许动态扩展时无法申请到足够内存而导致扩展失败时分别抛出`StackOverflowError`和`OutOfMemoryError`异常。
### 堆
`Java`堆是被所有线程共享的内存区域,在虚拟机启动时创建.此内存区域的唯一目的就是存放对象实例,垃圾收集器管理的也是此块区域.
如果不断创建对象，并且存在`GC Roots`到对象之间有可达路径(被引用)来避免垃圾回收时，会导致`OutOfMemoryError`。
### 方法区
方法区也是各个线程共享的内存区域,用于存储已被虚拟机加载的类型信息、 常量、静态变量、即时编译器编译后的代码缓存等数据.需要注意的是,永久代并不等同于方法区(可以不实现垃圾收集).
运行时常量池,用于存放类加载后`Class`文件中类的常量池表(通过类加载过程的`loading`部分),也是方法区的一部分.
> 可以理解为每一个类都有自身的运行时常量池,但并不意味着`constant pool`中所有的字段都会原样复制一份,需要关乎到具体的`jvm`实现.参照: [Runtime constant pool - is filled up by variables created in runtime?](https://stackoverflow.com/questions/43047852/runtime-constant-pool-is-filled-up-by-variables-created-in-runtime)

> 运行时常量池相对于`Class`常量池一大特征就是具有动态性，`java`规范并不要求常量只能在运行时才产生，也就是说运行时常量池的内容并不全部来自`Class`常量池，在运行时可以通过代码生成常量并将其放入运行时常量池中，这种特性被用的最多的就是`String.intern()`---拿`String`的内容去`StringTable`(除了运行时常量池和`Class`常量池,还有字符串常量池)里查表，如果存在，则返回引用，不存在，就把该对象的"引用"存在`StringTable`表里。

需要指出的是,`JDK6`常量池在永久代，与堆隔离，而自`JDK 7`起， 原本存放在永久代的字符串常量池被移至Java堆之中.

当方法区无法满足新的内存分配需求时(运行时产生大量的类),将抛出`OutOfMemoryError`异常.
### 直接内存
直接内存并不是虚拟机运行时数据区的一部分.比如在`JDK 1.4`中新加入的`NIO`类,可以使用`Native`函数库直接分配堆外内存.
它会受到本机物理内存大小的限制,因而可能会出现`OutOfMemoryError`异常(表现为`Dump`文件很小，但又使用了直接内存，例如`NIO`).
## 虚拟机对象
以`HotSpot`虚拟机为例，对于普通`Java`对象(不包括数组和`Class`对象)的创建，是从**遇到`new`指令开始**的。它首先将去检查指令的参数是否能在常量池中定位到一个类的符号引用，并且检查是否已经被加载、解析和初始化过。否则，将执行类加载过程。
类加载完成后，将为新生对象分配内存(类加载的准备阶段只为类变量分配了内存，实例变量在与对象实例化时一起分配内存)。分配内存有两种方案：
- 指针碰撞，适用于内存连续的情况，比如收集器具有整理的功能
- 空闲列表，由虚拟机维护列表记录可用的内存块

分配内存时为了解决并发的问题(避免不同的线程使用同一块内存给不同的对象分配)，有两种方案：
- `CAS`
- 每一个线程具有自己的内存空间，即本地线程分配缓冲(`TLAB`)，只在自己的缓冲区中进行分配

内存分配完后，虚拟机会将分配到的内存空间，除对象头以外初始化为对应类型的零值。因此对象的实例字段可以不赋初始值就能使用。接下来需要对对象头进行设置，用于记录对象的状态。

对象包括三个部分：
- 对象头(`Mark Word`)，包括两部分：
    - 存储对象自身运行数据：根据虚拟机的位数分别为`32`位或者`64`位。例如在`32`位机器中，有固定的`2`位表示标志位，剩下的位数根据对象所处的状态(比如轻量级锁定、重量级锁定等)存储不同的内容。
    - 类型指针：指向它的类型元数组的指针，用来确定对象是哪个类的实例。但并不是所有实现都会保留类型指针。比如使用句柄访问对象。
- 实例数据：代码里所定义的各种类型的字段内容，包括父类继承的
- 对齐填充:  起到占位符的作用，并不是一定存在的。

当执行完`new`指令后，会接着执行`init`方法，对对象进行初始化。这样一个对象才算是被真正构造出来。在构造之后，会通过栈上的`reference`来操作堆上的具体对象，而`reference`中存储的内容，取决于访问对象的方式，有两种方案：
- 句柄访问：会将堆中划分出一块内存作为句柄池，`reference`存储的是对象的句柄地址，这个句柄里包括指向堆的对象实例数据和指向方法区的对象类型数据。显然，如果对象发生了移动，只需要改动句柄中的值，并不需要对`reference`进行修改
![通过句柄访问对象](https://upload-images.jianshu.io/upload_images/12157360-3be3b412924e7abe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

- 直接指针访问：`reference`中存储的是对象的地址，对象中存在类型指针指向方法区的对象类型数据。这种方式节省了一次指针定位的时间开销，速度更快。
![通过直接指针访问对象](https://upload-images.jianshu.io/upload_images/12157360-81b25ec39c72c75f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

参考资料:
[彻底弄懂java中的常量池](https://cloud.tencent.com/developer/article/1450501)
深入理解Java虚拟机 第二章